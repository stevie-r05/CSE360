/*
* DBUsers.cpp
*
*  Created on: Mar 1, 2012
*      Author: Ian
*/
#include "stdafx.h"
#include "DB_Users.h"
#include "timingClass.h"

namespace CSE360Project {

	DB_Users::DB_Users() {
		database_file = "Users.db";

		//Open File
		this->Open(ios_base::in);

		//Load Data
		this->LoadData();

		//Close Data
		this->Close();
	}

	void DB_Users::LoadData() {
		//Clear data in preparation for loading data.  If it's empty, will have no effect
		clearDataArray<db_users_data>(user_data);

		//Open if not already open
		this->Open(ios_base::in);

		//Load last inserted id
		string lastID = "";
			char input_char;
		while (in.good()) {
			input_char = in.get();
			if (input_char == DATA_ROW_TERMINATE)
				break;

			lastID += input_char;
		}

		if (!lastID.empty()) {
			this->lastID = atoi(lastID.c_str());

			//Load Data
			//uid    username password lastName firstName securityQuestion securityAnswer userRole
			//	0		1		2			3		4					5			6       7
			int struct_position = 0;
			string uid, input_user_role;
			bool new_row = true; //Flag new row to create new struct

			cout << "Begin Users Read" << endl;
			while (in.good()) {
				//if new row is flagged, create it.
				if (new_row) {
					//Create data row
					user_data.push_back(*(new db_users_data));

					//un flag it.
					new_row = false;

					//set struct_position to 0 to begin data entry into new data row
					struct_position = 0;

					//clear uid for new row.
					uid.erase();

					//clear user role
					input_user_role.erase();
				}

				input_char = in.get();
				if (in.good()) {
					if (input_char == DATA_COL_DELIM) {
						//Col delim found, move to next struct location.
						struct_position++;
					} else if (input_char == DATA_ROW_TERMINATE) {
						//set flag to true, the next line
						new_row = true;
					} else {
						switch (struct_position) {
						case 0:
							uid += input_char;
							user_data.back().uid = atoi(uid.c_str());
							break;
						case 1:
							user_data.back().username += input_char;
							break;
						case 2:
							user_data.back().password += input_char;
							break;
						case 3:
							user_data.back().lastName += input_char;
							break;
						case 4:
							user_data.back().firstName += input_char;
							break;
						case 5:
							user_data.back().securityQuestion += input_char;
							break;
						case 6:
							user_data.back().securityAnswer += input_char;
							break;
						case 7:
							input_user_role += input_char;
							switch (atoi(input_user_role.c_str())) {
							case admin:
								user_data.back().userRole  = admin;
								break;
							case teacher:
								user_data.back().userRole  = teacher;
								break;
							default:
								user_data.back().userRole  = student;
								break;
							}
						}
					}
				}
			}
		}

		//Close
		this->Close();
	}

	void DB_Users::Write() {
		//Open file
		this->Open(ios_base::out);

		timingClass timing;
		timing.tic();

		//Write Data
		int data_array_size = (int) user_data.size();

		//Write last ID
		out << user_data.back().uid << DATA_ROW_TERMINATE;

		for (int i = 0; i < data_array_size; i++) {
			//This adds a termination to the end of the last data row.  This prevents 'ghost records' at the end of the file.
			if (i > 0)
				out << DATA_ROW_TERMINATE;


			out << user_data[i].uid << DATA_COL_DELIM; //User ID - Autogenerated in this class.
			out << user_data[i].username << DATA_COL_DELIM;
			out << user_data[i].password << DATA_COL_DELIM;
			out << user_data[i].lastName << DATA_COL_DELIM;
			out << user_data[i].firstName << DATA_COL_DELIM;
			out << user_data[i].securityQuestion << DATA_COL_DELIM;
			out << user_data[i].securityAnswer << DATA_COL_DELIM;
			out << user_data[i].userRole;
		}

		out.close();
		this->writeBenchmark(data_array_size,timing.toc());
	}

	int DB_Users::Insert(db_users_data *user_data) {

		return 0;
	}

	bool DB_Users::validateUser(string username, string password) {
		int vector_index = getVectorIndex(username);

		if (vector_index >= 0 && password.compare(user_data[vector_index].password) == 0) {
			return true;
		}

		return false;
	}

	bool DB_Users::checkSecurityAnswer(string username, string answer) {
		int vector_index = getVectorIndex(username);

		if (vector_index >= 0 && answer.compare(user_data[vector_index].securityAnswer) == 0) {
			return true;
		}

		return false;
	}

	user_roles_t DB_Users::getUserRole(int uid) {
		return user_data[getVectorIndex(uid)].userRole;
	}

	string DB_Users::getUsername(int uid) {
		return user_data[ getVectorIndex(uid) ].username;
	}

	string DB_Users::getFirstname(int uid) {
		return user_data[ getVectorIndex(uid) ].firstName;
	}

	string DB_Users::getLastname(int uid) {
		return user_data[ getVectorIndex(uid) ].lastName;
	}

	string DB_Users::getSecurityQuestion(string username) {
		int vector_index = getVectorIndex(username);

		if (vector_index >= 0)
			return user_data[ vector_index ].securityQuestion;

		return "invalid";
	}

	int DB_Users::getUID(string username) {
		int vector_index = getVectorIndex(username);

		if (vector_index >= 0)
			return user_data[vector_index].uid;

		return 0;
	}

	int DB_Users::getVectorIndex(string username) {
		for (int i = 0; i < (int) user_data.size(); i++) {
			if (username.compare(user_data[i].username) == 0) {
				return i;
			}
		}

		return -1;
	}

	int DB_Users::getVectorIndex(int uid) {
		for (int i = 0; i < (int) user_data.size(); i++) {
			if (uid == user_data[i].uid) {
				return i;
			}
		}

		return -1;
	}

	void DB_Users::outputAllUsers() {
		if (!user_data.empty()) {
			for (int i = 0; i < (int) user_data.size(); i++) {
				cout << i+1 << ") ";
				cout << "uid: " << user_data[i].uid << endl; //User ID - Autogenerated in this class.
				cout << "username: " << user_data[i].username << endl;
				cout << "password: " << user_data[i].password << endl;
				cout << "lname: " << user_data[i].lastName << endl;
				cout << "fname: " << user_data[i].firstName << endl;
				cout << "question: " << user_data[i].securityQuestion << endl;
				cout << "answer: " << user_data[i].securityAnswer << endl;
				cout << "role: ";
				switch (user_data[i].userRole) {
				case admin:
					cout << "Admin";
					break;
				case teacher:
					cout << "Teacher";
					break;
				default:
					cout << "Student";
					break;
				}
				cout << endl << endl;
			}
		} else {
			cout << "User Data is empty." << endl;
		}

		this->Write();
	}

	DB_Users::~DB_Users() {
		// TODO Auto-generated destructor stub
	}

} /* namespace CSE360Project */