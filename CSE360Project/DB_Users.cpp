/*
* DBUsers.cpp
*
*  Created on: Mar 1, 2012
*      Author: Ian
*/
#include "stdafx.h"
#include "DB_Users.h"
#include "timingClass.h"

namespace CSE360Project {

	DB_Users::DB_Users() {
		database_file = "Users.db";

		//Open File
		this->Open(ios_base::in);

		//Load Data
		this->LoadData();

		//Close Data
		this->Close();
	}

	void DB_Users::LoadData() {
		//variable declarations
		char input_char; //Will hold the character just read and being processed.
		int struct_position = 0; //Current struct position, will iterate upon reading DATA_COL_DELIM and reset to 0 on DATA_ROW_TERMINATE
		string uid; //for reading in arbitrary lengthed uid.
		string input_user_role; //for reading in arbitrary lengthed user_role.
		bool new_row = true; //Flag new row to create new struct

		//Clear data in preparation for loading data.  If it's empty, will have no effect
		user_data.clear();

		//Open if not already open
		this->Open(ios_base::in);

		//Load last inserted id
		string lastID = "";
		while (in.good()) {
			input_char = in.get();

			//If terminate character is read we are done reading lastID
			if (input_char == DATA_ROW_TERMINATE)
				break;

			//If terminate character not read, we're still in last id.
			lastID += input_char;
		}

		if (!lastID.empty()) {
			//If last id is not empty, cast it to interger and save it!
			this->lastID = atoi(lastID.c_str());

			//Load Data
			//uid    username password lastName firstName securityQuestion securityAnswer userRole
			//	0		1		2			3		4					5			6       7

			//cout << "Begin Users Read" << endl; //removed, debug only.
			while (in.good()) {
				//if new row is flagged, create it.
				if (new_row) {
					//Create data row
					user_data.push_back(*(new db_users_data));

					//un flag it.
					new_row = false;

					//set struct_position to 0 to begin data entry into new data row
					struct_position = 0;

					//clear uid for new row.
					uid.erase();

					//clear user role
					input_user_role.erase();
				}

				input_char = in.get();
				if (in.good()) {
					if (input_char == DATA_COL_DELIM) {
						//Col delim found, move to next struct location.
						struct_position++;
					} else if (input_char == DATA_ROW_TERMINATE) {
						//set flag to true, the next line
						new_row = true;
					} else {
						switch (struct_position) {
						case 0:
							//add input_char to uid, cast to int to store.  if uid is partial it will replace itself until it's complete.
							uid += input_char;
							user_data.back().uid = atoi(uid.c_str());
							break;
						case 1:
							user_data.back().username += input_char;
							break;
						case 2:
							user_data.back().password += input_char;
							break;
						case 3:
							user_data.back().lastName += input_char;
							break;
						case 4:
							user_data.back().firstName += input_char;
							break;
						case 5:
							user_data.back().securityQuestion += input_char;
							break;
						case 6:
							user_data.back().securityAnswer += input_char;
							break;
						case 7:
							input_user_role += input_char;
							switch (atoi(input_user_role.c_str())) {
							case admin:
								user_data.back().userRole  = admin;
								break;
							case teacher:
								user_data.back().userRole  = teacher;
								break;
							default:
								user_data.back().userRole  = student;
								break;
							}
						}
					}
				}
			}
		}

		//Close
		this->Close();
	}

	void DB_Users::Write() {
		//Open file
		this->Open(ios_base::out);

		//Create timing class, and tic value.  Tic = start temporary timer variable.
		timingClass timing;
		timing.tic();

		//Write Data
		int data_array_size = (int) user_data.size();

		//Write last ID
		out << user_data.back().uid << DATA_ROW_TERMINATE;

		for (int i = 0; i < data_array_size; i++) {
			//This adds a termination to the end of the last data row.  This prevents 'ghost records' at the end of the file.
			if (i > 0)
				out << DATA_ROW_TERMINATE;


			out << user_data[i].uid << DATA_COL_DELIM; //User ID - Autogenerated in this class.
			out << user_data[i].username << DATA_COL_DELIM;
			out << user_data[i].password << DATA_COL_DELIM;
			out << user_data[i].lastName << DATA_COL_DELIM;
			out << user_data[i].firstName << DATA_COL_DELIM;
			out << user_data[i].securityQuestion << DATA_COL_DELIM;
			out << user_data[i].securityAnswer << DATA_COL_DELIM;
			out << user_data[i].userRole;
		}

		out.close();
		this->writeBenchmark(data_array_size,timing.toc());
	}

	int DB_Users::Insert(db_users_data *user_data) {
		//We need to error check, if they are already a user, do nothing.
		this->user_data.push_back(*user_data);
		return 0;
	}

	bool DB_Users::validateUser(string username, string password) {
		int vector_index = getVectorIndex(username);

		if (vector_index >= 0 && password.compare(user_data[vector_index].password) == 0) {
			return true;
		}

		return false;
	}

	bool DB_Users::checkSecurityAnswer(string username, string answer) {
		int vector_index = getVectorIndex(username);

		if (vector_index >= 0 && answer.compare(user_data[vector_index].securityAnswer) == 0) {
			return true;
		}

		return false;
	}

	user_roles_t DB_Users::getUserRole(int uid) {
		return user_data[getVectorIndex(uid)].userRole;
	}

	string DB_Users::getUsername(int uid) {
		return user_data[ getVectorIndex(uid) ].username;
	}

	string DB_Users::getFirstname(int uid) {
		return user_data[ getVectorIndex(uid) ].firstName;
	}

	string DB_Users::getLastname(int uid) {
		return user_data[ getVectorIndex(uid) ].lastName;
	}

	string DB_Users::getSecurityQuestion(string username) {
		int vector_index = getVectorIndex(username);

		if (vector_index >= 0)
			return user_data[ vector_index ].securityQuestion;

		return "invalid";
	}

	int DB_Users::getUID(string username) {
		int vector_index = getVectorIndex(username);

		if (vector_index >= 0)
			return user_data[vector_index].uid;

		return 0;
	}

	int DB_Users::getVectorIndex(string username) {
		for (int i = 0; i < (int) user_data.size(); i++) {
			if (username.compare(user_data[i].username) == 0) {
				return i;
			}
		}

		return -1;
	}

	int DB_Users::getVectorIndex(int uid) {
		for (int i = 0; i < (int) user_data.size(); i++) {
			if (uid == user_data[i].uid) {
				return i;
			}
		}

		return -1;
	}

	void DB_Users::outputAllUsers() {
		//write test user
		/*
		db_users_data *user = new db_users_data;
		user->uid = ++lastID;
		user->username = "dnewton";
		user->password = "david_password";
		user->lastName = "Newton";
		user->firstName = "David";
		user->securityQuestion = "Hey there?";
		user->securityAnswer = "Hi.";
		user->userRole = teacher;
		*/

		this->Insert(user);

		if (!user_data.empty()) {
			for (int i = 0; i < (int) user_data.size(); i++) {
				cout << i+1 << ") ";
				cout << "uid: " << user_data[i].uid << endl; //User ID - Autogenerated in this class.
				cout << "username: " << user_data[i].username << endl;
				cout << "password: " << user_data[i].password << endl;
				cout << "lname: " << user_data[i].lastName << endl;
				cout << "fname: " << user_data[i].firstName << endl;
				cout << "question: " << user_data[i].securityQuestion << endl;
				cout << "answer: " << user_data[i].securityAnswer << endl;
				cout << "role: ";
				switch (user_data[i].userRole) {
				case admin:
					cout << "Admin";
					break;
				case teacher:
					cout << "Teacher";
					break;
				default:
					cout << "Student";
					break;
				}
				cout << endl << endl;
			}
		} else {
			cout << "User Data is empty." << endl;
		}

		this->Write();
	}

	DB_Users::~DB_Users() {
		user_data.clear();
	}

} /* namespace CSE360Project */